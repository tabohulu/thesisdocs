\section{Introduction}

The RSC code, developed by Punya Thitimajshima, was first introduced in the Claude Berrou's 1993 paper \cite{Berrou93-05C} as the 
{\it component code} (CC) for the then newly invented TC, which is one of the \textit{forward-error correcting} (FEC) codes that comes very close to satisfying the Shannon limit for AWGN channels.  2 years after \cite{Berrou93-05C}, \cite{Thitimajshima95-11C} was published, giving more details on the RSC code. Subsequently, \cite{Benedetto96-05J}, which detailed the inner workings of parallel concatenated codes, proved why RSC codes are better suited for use in the TC (better performance at any SNR for high code rate compared to other classes of convolutional codes) and in so doing, established them as the CC of choice for the TC.

Due to the success of the TC,  it has been adopted by many industral standards \cite{802-16e-04S}, \cite{dvb-rcs2-S},\cite{LTE-S} and the RSC code has been adopted as the CC for many other concatenated coding schemes. Examples include {\it recursive convolutional space-time codes} (ReC-STC) designed by adopting several parallel two-state RSC codes \cite{Ying05-07L}, a concatenated code obtained by combining a RSC code with a {\it Low-Density Parity-Check} (LDPC) code \cite{Gounai06-06C}, {\it binary self-concatenated convolutional codes employing iterative decoding} (SECCC-ID) with RSC codes as the CC \cite{Butt08-11C} and the {\it Reed-Solomon Convolutional Code} (RS-CC) concatenated code \cite{Xu07-04C}, \cite{Byun10-09C},\cite{Joshi11-11C}.  Despite the performance of these concatenated codes, the RSC code remains associated with the TC.

%RSC codes are used in concatenated codes as the binary inner code, where the codewords become the symbols to the outer non-binary code \cite{Proakis08B}. An example of such a code is the {\it Reed-Solomon Convolutional Code} (RS-CC) concatenated code, which is widely used various sysytems and widely researched \cite{Xu07-04C}, \cite{Byun10-09C},\cite{Joshi11-11C}, \cite{Joshi12-08C}. However, RSC codes were originally developed for use in parallel concatenation codes, and their most popular application is as the component code for TCs.

 The TC is generally constructed by concatenating two RSC codes (usually of the same kind) parallely  via an interleaver . A well designed TC realizes a large minimum distance via the interleaver, if it maps each bit sequence wit a  low-weight PC in the first RSC code onto that with a high-weight PC in the second RSC code.
Thus, the design of a good deterministic interleaver requires the complete knowledge of all the low-weight codeword component patterns of the employed RSC code and missing even one of these patterns may result in TC with subpar error correction performance.

The transfer function of an RSC code is an interleaver design tool that provides information about the different weights in the code, as well as their corresponding multiplicities (distance spectrum). 
However, it provides no information with regards to the pattern of the low-weight codeword components. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states, and other methods such as Mason's Rule \cite{Moon05B} have to be used. Research into other methods for finding the distance spectrum have been carried out in recent years.  In \cite{Lu16-10C}, an algorithm for evaluating the input-parity weight distribution of
terminated RSC codes is presented, while in \cite{Deng17-01C}, the distance spectrum of tail-biting duo-binary
RSC codes is calculated using the modified FAST algorithm. These methods also do not reveal the pattern of the low-weight codeword components and to the best of our knowledge, there exists no interleaver design tool that provides complete knowledge of the low-weight codewords. Because of this, many of the interleaver design methods end up completely ignoring certain important low-weight codewords. In \cite{Sun05-01J} for example, the interleaver design method does not take into account the existence of low-weight codewords with systematic components of weight 3, especially for the $5/7$  RSC code, where such codewords are dominant.

In this paper, we propose a method to obtain complete information about the low-weight codeword components. The complexity of our proposed method is independent of the number of states of the RSC code and its ability to also reveal the low-weight codeword patterns of an RSC code makes it an excellent interleaver design tool.
We establish the low-weight codewords for the given RSC code by identifying codewords with either PCs or SCs of weight-2 and weight-3. Then, using the established low-weight codewords, we validate our proposed method by obtaining a union bound and comparing it to that obtained via the transfer function method and the BER curve obtained via simulation results.

The remainder of the research paper is organised as follows. Definitions used in this paper are introduced in Section \ref{secPrelim}. In Section \ref{sec2}, we discuss the characteristics of the low-weight RSC codewords and then present our method in Section \ref{sec3}. Validation of our proposed method for specific RSC codes as well as discussion of numerical results is done in Section \ref{sec4} and the paper concludes in Section \ref{sec6}.

\subsection{Notations}

For two positive integers $\alpha$ and $\beta$, the least common multiple of $\alpha$ and $\beta$ is dentoed as $\lcm(\alpha,\beta)$ while the remainder $\alpha$ divided by $\beta$ is denoted as $\alpha \mod \beta$. $\alpha | \beta$ implies $\alpha$ is a divisor of $\beta$. For an integer pair $(\alpha,~\beta)$, $(\alpha,~\beta) \bmod \epsilon_0$ is shorthand for the operation $(\alpha \bmod \epsilon_0,~\beta \bmod \epsilon_0)$. The sets of non-negative and positive integers are denoted by $\bbZ$ and $\bbZ^+$, respectively. For two integer sets $\bbM$ and $\bbN$, the tensor product that yields the set consisting of all pairs of $\bbM$ and $\bbN$ is denoted as $\bbM \otimes \bbN$ and we assume the elements in each resultant pair are sorted in increasing order. 


