\section{Introduction}

The Turbo Code (TC) \cite{ref1} is among the forward-error correcting codes that come very close to satisfying the Shannon limit for AWGN channels. It was introduced by Claude Berrou in 1993 and steadily gained fame and has been used in many applications and industry standards. It has been adopted as the standard channel code for the LTE standard, IEEE 802.16 WiMAX (worldwide interoperability for microwave access) and DVB-RCS2 (2nd generation digital video broadcasting - return channel via satellite) standards \cite{ref7}.

 The simplest and most common construction of a TC is the parallel concatenation of two recursive systematic convolutional (RSC) codes (of the same kind) via an interleaver. One of the many reasons why the TC excels as a channel code is its ability to map low-weight parity-check sequences in one RSC code to high-weight parity-check sequences in the other, which in turn generates TCs with a large minimum distance value.
%The reason why the TC has such a good error correcting capability has been attributed to the low multiplicity of its minimum distance codeword and through many years of intensive research in the field, it is common knowledge that this is largely due to the use of the interleaver in the TC construction.

 For this reason, interleaver design for TCs has been a hot topic for many years and generally, they are grouped into random and deterministic interleavers. Random interleavers determine their order of permutation in a pseudo-random manner. TCs using random interleavers usually have good error-correcting capabilities but imposes huge memory constraints for many practical applications due to the use of interleaver tables. A notable example of a random interleaver is the S-random interleaver.
% and therefore require interleaver tables in both the transmitter and the receiver. Even though TCs made with random interleavers have very good error-correcting capabilities (especially for medium and long frame sizes), the need for interleaver tables imposes huge memory constraints for many practical applications. A notable example of a random interleaver is the S-random interleaver.

On the flip side, deterministic interleavers generate their order of 
permutation via \newline algorithms and, as such, can be generated on the fly, killing the need for permutation tables. 
Popular deterministic interleavers include quadratic permutation polynomial (QPP) interleaver \cite{ref5}, almost regular permutation (ARP) interleaver and dithered relative prime (DRP) interleaver. A protograph based interleaver design for punctured turbo codes is also introduced in \cite{ref7}
Deterministic interleavers also make it possible to perform parallel decoding once the interleaver meets certain requirements. Despite all these benefits, it is a well-known fact that in terms of TC error-correcting performance, random interleavers always outperform deterministic interleavers, especially for long frame sizes.
%Another benefit of using deterministic interleavers is the ability to custom design the interleaver to a specific component code to improve the overall error-correcting capability of the TC. 

%The most common approach to deterministic interleaver design is the minimum free distance ($d_{\text{free}}$) maximisation approach, where the interleaver is designed with the aim of maximising the value of $d_{\text{free}}$. This approach, while simplistic, has produced some good interleavers only after considering higher weight inputs \cite{ref5}. Therefore,
%using it as a general rule of thumb for all deterministic interleaver design approaches might not be the best, especially when the minimum distance codeword for the component code is generated by an input message with a weight greater than 2. 
The design of good deterministic interleavers requires the complete knowledge of all input patterns that generate low-weight codewords in the component codes. We refer to these inputs as Return-to-Zero (RTZ) inputs \cite{ref6}. Missing even one of these patterns can result in deterministic interleavers that generate TCs with sub-par error correction performance.
The transfer function of an RSC code is an interleaver design tool that provides information about the different weights in a code as well as their corresponding multiplicities (distance spectrum). However, it provides no information with regards to the pattern of the RTZ inputs. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states. To the best of our knowledge, there exists no interleaver design tool that provides knowledge of the distance spectrum and the RTZ input patterns. Because of this many of the interleavers that have been designed based on assumptions which completely ignore certain important RTZ inputs. In \cite{ref5} for example, the interleaver design method does not take into account the existence of RTZ inputs of weight 3, especially for the $5/7$  RSC code where this RTZ input is very dominant with a high multiplicity.

In this paper,we present a novel method that can be used to find the distance spectrum of an RSC code as well as the pattern of the RTZ inputs and their corresponding parity-check sequences. The complexity of our method is independent of the number of states of the RSC code and its ability to reveal the pattern of RTZ inputs of the RSC code makes it an excellent tool for use in interleaver design.

In order to validate our method, we  we generate a partial distance spectrum for specific RSC codes and compare it to the lower bound obtained via the transfer function method. We also compare the bounds obtained using our novel method to simulation results. In both cases, it is observed that the values begin to converge as $E_b/N_0$ increases.

The remainder of the research paper is organised as follows. In Section \ref{sec2}, we briefly introduce the notations and assumptions that will be used in the research paper. Then,we briefly review the RSC codes in Section \ref{sec3} . Moving on to Section \ref{sec5}, 
we briefly describe how the distance spectrum of an RSC Code is obtained using the transfer function, followed by the presentation of our novel method. Simulation results are presented in Section \ref{sec6} and conclude in Section \ref{sec7}.