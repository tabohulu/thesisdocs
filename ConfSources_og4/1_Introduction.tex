\section{Introduction}

The {\it turbo code} (TC) \cite{ref1}, introduced by Claude Berrou in 1993 is one of the \textit{forward-error correcting} (FEC) codes that comes very close to satisfying the Shannon limit for AWGN channels.  Due to its excellent performance, TCs have been used in many applications,  and  have been adopted as the channel code for the LTE standard, IEEE 802.16 WiMAX (worldwide interoperability for microwave access) and DVB-RCS2 (2nd generation digital video broadcasting - return channel via satellite) standards \cite{ref7}.

 The simplest and most common construction of a TC is  to concatenate  two {\it recursive systematic convolutional} (RSC) codes (usually of the same kind) parallely  via an interleaver. One of the many reasons why the TC excels as a FEC code is due to its ability to map low-weight parity-check sequences in the first RSC code to high-weight parity-check sequences in the second RSC code using the interleaver, which in turn generates TCs with a large minimum distance value.
%The reason why the TC has such a good error correcting capability has been attributed to the low multiplicity of its minimum distance codeword and through many years of intensive research in the field, it is common knowledge that this is largely due to the use of the interleaver in the TC construction.

% For this reason, interleaver design for TCs has been highly researched for many years and generally, they are grouped into random and deterministic interleavers. Random interleavers determine their order of permutation in a pseudo-random manner. TCs using random interleavers usually have good error-correcting capabilities but impose huge memory constraints for many practical applications due to the use of interleaver tables. A notable example of a random interleaver is the S-random interleaver.
% and therefore require interleaver tables in both the transmitter and the receiver. Even though TCs made with random interleavers have very good error-correcting capabilities (especially for medium and long frame sizes), the need for interleaver tables imposes huge memory constraints for many practical applications. A notable example of a random interleaver is the S-random interleaver.

%On the other hand, deterministic interleavers generate their order of 
%permutation via \newline algorithms and as such, can be generated on the fly, and do not require permutation tables. 
%Popular deterministic interleavers include \textit{quadratic permutation polynomial} (QPP) interleaver \cite{ref5}, \textit{almost regular permutation} (ARP) interleaver \cite{ref6} and \textit{dithered relative prime} (DRP) interleaver. A protograph based interleaver design for punctured turbo codes is also introduced in \cite{ref7}. 
%Deterministic interleavers also make it possible to perform parallel decoding once the interleaver meets certain requirements. Despite all these benefits, it is a well-known fact that in terms of TC error-correcting performance, random interleavers always outperform deterministic interleavers, especially for long frame sizes.

%Another benefit of using deterministic interleavers is the ability to custom design the interleaver to a specific component code to improve the overall error-correcting capability of the TC. 

%The most common approach to deterministic interleaver design is the minimum free distance ($d_{\text{free}}$) maximisation approach, where the interleaver is designed with the aim of maximising the value of $d_{\text{free}}$. This approach, while simplistic, has produced some good interleavers only after considering higher weight inputs \cite{ref5}. Therefore,
%using it as a general rule of thumb for all deterministic interleaver design approaches might not be the best, especially when the minimum distance codeword for the component code is generated by an input message with a weight greater than 2. 

The design of a good deterministic interleaver requires the complete knowledge of all the low-weight codeword component patterns in the RSC code and missing even one of these patterns can result in deterministic interleavers that generate TCs with sub-par error correction performance.
The transfer function of an RSC code is an interleaver design tool that provides information about the different weights in the code, as well as their corresponding multiplicities (distance spectrum). 
%The distance spectrum of the RSC code can be obtained from its transfer function, denoted by $$T(Y,X)=\sum_{d=0}^{\infty}\sum_{w=0}^{\infty} a(d,w)Y^dX^w$$ where $a(d,w)$ is the number of codewords of weight $d$ generated by an input bit sequence of weight $w$. 
%The transfer function enumerates all the paths that diverge from and then return to the initial state \cite{ref3}, \textit{i.e.} the RTZ input paths. 
%Once the transfer function of an RSC code is known, it can be used to obtain bounds on the error-correcting capability using the union bound.
%Unfortunately, the complexity involved in deriving the transfer function increases as the number of states of the RSC code increases and other methods such as Mason's Rule \cite{ref3} have to be used. 
However, it provides no information with regards to the pattern of the low-weight codeword components. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states, and other methods such as Mason's Rule \cite{ref3} have to be used. Research into other methods for finding the distance spectrum have been carried in recent years.  In \cite{ref8}, an algorithm for evaluating the input-parity weight distribution of
terminated RSC codes is presented, while in \cite{ref9}, the distance spectrum of tail-biting duo-binary
RSC codes is calculated using the modified FAST algorithm. These methods also do not reveal the pattern of the low-weight codeword components and to the best of our knowledge, there exists no interleaver design tool that provides knowledge of both the distance spectrum and the low-weight codeword component patterns. Because of this, many of the interleaver design methods end up completely ignoring certain important low-weight codewords. In \cite{ref5} for example, the interleaver design method does not take into account the existence of low-weight codewords with systematic components of weight 3, especially for the $5/7$  RSC code, where such codewords are dominant.

In this paper, we propose a novel method for revealing the pattern of the low-weight codeword components. The complexity of our proposed method is independent of the number of states of the RSC code and its ability to reveal the low-weight codeword patterns of an RSC code makes it an excellent interleaver design tool.
We generate a low-weight codeword component pattern list for specific RSC codes and obtain union bounds using our proposed method. We then validate our method by comparing the proposed union bounds to simulation results and the union bounds obtained via the transfer function method.

The remainder of the research paper is organised as follows. Definitions used in the research paper are introduced in Section \ref{secPrelim}. In Section \ref{sec2}, we establish the theoretical foundations for our novel method by discussing the characteristics of the low-weight codewords. Then in Section \ref{sec3}, we present our novel method and use examples to clarify the workings of our proposed method. Validation of our proposed method for specific RSC codes as well as discussion of numerical results is done in Section \ref{sec4} and the paper concludes in Section \ref{sec6}.

\subsection{Notations}

For two positive integers $\alpha$ and $\beta$, the least common multiple of $\alpha$ and $\beta$ is dentoed as $\lcm(\alpha,\beta)$ while the remainder $\alpha$ divided by $\beta$ is denoted as $\alpha \mod \beta$. $\alpha | \beta$ implies $\alpha$ is a divisor of $\beta$. For an integer pair $(\alpha,~\beta)$, $(\alpha,~\beta) \bmod \epsilon_0$ is shorthand for the operation $(\alpha \bmod \epsilon_0,~\beta \bmod \epsilon_0)$. For two integer sets $\cM$ and $\cN$, the tensor product that yields the set consisting of all pairs of $\cM$ and $\cN$ is denoted as $\cM \otimes \cN$ and we assume the elements in each resultant pair are sorted in increasing order. 


