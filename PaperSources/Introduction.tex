\section{Introduction}
The Turbo Code (TC) \cite{ref1}, is known for being one of the forward-error correcting codes that come very close to satisfying the Shannon limit for AWGN channels. It was introduced by Claude Berrou in 1993 and steadily gained fame and has been used in many applications 
including Mobile and Satelite communication networks. The simplest and most common construction of the TC is via the parallel concatenation of two Recursive Systematic Convolutional (RSC) codes (of the same kind) via an interleaver. The reason why the TC has such a good error correcting capability has been attributed to the low multiplicity of its minimum distance codeword and through many years of intensive research in the field, it is common knowledge that this is largely due to the use of the interleaver in the TC construction.

Interleaver design for TCs has been a hot topic for many years and generally, they are grouped into random and deterministic interleavers. Random interleavers determine their order of permutation in a pseudo random manner and therefore require interleaver tables in both the transmitter and the receiver. Even thought TCs made with random interleavers have really good error-correcting capabilities (especially for medium and long frame sizes), the need for interleaver tables imposes huge memory constraints for many practical applications. A notable example of a random interleaver is the S-random interleaver.

On the flip side, deterministic interleavers generate their order of permutation via algorithims and as such can be generated on the fly, killing the need for permutation tables. Popular deterministic interleavers include Quadratic Permutation Polynomial (QPP) interleaver \cite{ref5}, Almost Regular Permutation (ARP) Interleaver and the Dithered Relative Prime (DRP) interleaver. Deterministic interleavers also make it possible to perform parallel decoding, once the interleaver meets certain requirements. Given all these benefits, it is a well known fact that in terms on TC error-correcting performace random interleavers always outperform deterministic interleavers, especially for long frame sizes.
Another benefit of using deterministic interleavers is the ability to custom design the interleaver to a specific component code to improve the overall error-correcting capability of the TC. 

The most common approach to deterministic interleaver design is the minimum free distance ($d_{\text{free}}$) maximization approach, where the interleaver is designed with the aim to maximize the value of $d_{\text{free}}$. This approach whilst simplistic, has produced some good interleavers only after considering higher weight inputs \cite{ref5}. Therfore,
using it as a general rule of thumb for all deterministic interleaver design approaches might not be the best, especially when the minimum distance codeword for the component code is generated by an input message with weight greater than 2. 

To better design custom interleavers for a specific component code requires deep knowledge of its distance spectrum, more specifically the general structure of the message inputs that make up the distance spectrum. These message inputs are such that they diverge from and then return to the initial stateand are refered to as Return-To-Zero (RTZ) inputs
There are many methods available for obtaining the distance spectrum of an RSC code including finding the transfer function of the RSC code \cite{ref3}.
However, the transfer function method is not a very helpful tool when it comes to custom interleaver design since aside information about the number of codewords of weight $d$ generated by a message input of weight $w$, it provides zero information about the structure of the RTZ inputs. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states.



%A Convolutional Code (CC) is generated by passing an input message through a linear finite-state shift register. The structure of this code is such that it is best described using a trellis. This structure makes it possible to employ soft decision decoding algorithms, the most popular of these algorithms being the Viterbi algorithm. CC are used extensively in mobile communication and space communication application as a major component in concatenated code.  Depending on the configuration of the shift register being used to generate the code, a CC can either be \textit{recursive} or \textit{nonrecursive}. In the case of the recursive CC, a feedback shift register is used to generate the code. Furthermore if the input message appears in the CC, it is known as \textit{systematic}. Recursive Sytematic Convolutional (RSC) codes are used as component codes for turbo codes, which are one of the few error correcting codes with performance very close to the Shannon limit [1].

%Low weight codeword are produced when the parity bit sequence has a very low weight. Amongst all such codewords, the one with the lowest weight determines the free distance $d_{\text{free}}$ of the code. 
%$d_{\text{free}}$  of a RSC code is a very important factor and determines its error-correction performance [4].  This can be obtained from the distance spectrum of the RSC code which requires the calculation of the transfer function. The distance spectrum provides information about the number of codewords of weight $d$ generated by a message input of weight $w$. 
%The message inputs are such that they diverge from and then return to the initial state, assuming edge effect is ignored. These message inputs are referred to as Return-To-Zero (RTZ) inputs and with respect to interleaver design for turbo codes, the structure of these inputs makes it possible to design good interleavers.
%For this reason, the distance spectrum obtained as a result of the transfer function is not very useful, since it provides no information about the structure of the RTZ inputs. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states.

In this paper,we present a novel alternate method to the Transfer Function whose complexity is independent of the number of states of the component code, and has the added benefit of making known the structure of the RTZ inputs that make up the distance spectrum.
With the knowledge of the structure of the message inputs, we derive a general polynomial representation for them based on the weight of the message input after which we go a step further and derive corresponding parity-weight equations for the codewords they generate. Finally, a summary of the structure of the message inputs as well as their corresponding parity weight equations is tabulated for different RSC codes.
 %%%%%%%%%%%%%%%%%%%%%%
%Finally, we compare the upper bound for both methods to simulation results and it is revealed that the upper bound obtained by the novel method is much tighter.

%The rest of the research paper is organised as follows. In Section \ref{sec2}, we give a brief review of RSC codes. In section \ref{sec3}, we describe how the distance spectrum of a RSC Code is obtained using the transfer function, followed by the presentation of our novel method in Section \ref{sec4}. Simulation results are presented in Section \ref{sec5} and we draw conclusions in Section \ref{sec6}