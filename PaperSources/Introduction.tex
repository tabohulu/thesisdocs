\section{Introduction}
The Turbo Code (TC) \cite{ref1} is among the forward-error correcting codes that come very close to satisfying the Shannon limit for AWGN channels. It was introduced by Claude Berrou in 1993 and steadily gained fame and has been used in many applications, 
including mobile and satellite communication networks. The simplest and most common construction of a TC is the parallel concatenation of two recursive systematic convolutional (RSC) codes (of the same kind) via an interleaver. The reason why the TC has such a good error correcting capability has been attributed to the low multiplicity of its minimum distance codeword and through many years of intensive research in the field, it is common knowledge that this is largely due to the use of the interleaver in the TC construction.

Interleaver design for TCs has been a hot topic for many years and generally, they are grouped into random and deterministic interleavers. Random interleavers determine their order of permutation in a pseudo-random manner and therefore require interleaver tables in both the transmitter and the receiver. Even though TCs made with random interleavers have very good error-correcting capabilities (especially for medium and long frame sizes), the need for interleaver tables imposes huge memory constraints for many practical applications. A notable example of a random interleaver is the S-random interleaver.

On the flip side, deterministic interleavers generate their order of 
permutation via \newline algorithms and, as such, can be generated on the fly, killing the need for permutation tables. Popular deterministic interleavers include quadratic permutation polynomial (QPP) interleaver \cite{ref5}, almost regular permutation (ARP) interleaver and dithered relative prime (DRP) interleaver. Deterministic interleavers also make it possible to perform parallel decoding once the interleaver meets certain requirements. Given all these benefits, it is a well-known fact that in terms of TC error-correcting performance, random interleavers always outperform deterministic interleavers, especially for long frame sizes.
Another benefit of using deterministic interleavers is the ability to custom design the interleaver to a specific component code to improve the overall error-correcting capability of the TC. 

The most common approach to deterministic interleaver design is the minimum free distance ($d_{\text{free}}$) maximisation approach, where the interleaver is designed with the aim of maximising the value of $d_{\text{free}}$. This approach, while simplistic, has produced some good interleavers only after considering higher weight inputs \cite{ref5}. Therefore,
using it as a general rule of thumb for all deterministic interleaver design approaches might not be the best, especially when the minimum distance codeword for the component code is generated by an input message with a weight greater than 2. 

To better design custom interleavers for a specific component code requires deep knowledge of its distance spectrum, more specifically, the general structure of the message inputs that make up the distance spectrum. These message inputs are such that they diverge from and then return to the initial state and are referred to as Return-To-Zero (RTZ) inputs.
There are many methods available for obtaining the distance spectrum of an RSC code, including finding the transfer function of the RSC code \cite{ref3}.
However, the transfer function method is not a very helpful tool when it comes to custom interleaver design because, aside information about the number of codewords of weight $d$ generated by a message input of weight $w$, it provides zero information about the structure of the RTZ inputs. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states.



%A Convolutional Code (CC) is generated by passing an input message through a linear finite-state shift register. The structure of this code is such that it is best described using a trellis. This structure makes it possible to employ soft decision decoding algorithms, the most popular of these algorithms being the Viterbi algorithm. CC are used extensively in mobile communication and space communication application as a major component in concatenated code.  Depending on the configuration of the shift register being used to generate the code, a CC can either be \textit{recursive} or \textit{nonrecursive}. In the case of the recursive CC, a feedback shift register is used to generate the code. Furthermore if the input message appears in the CC, it is known as \textit{systematic}. Recursive Sytematic Convolutional (RSC) codes are used as component codes for turbo codes, which are one of the few error correcting codes with performance very close to the Shannon limit [1].

%Low weight codeword are produced when the parity bit sequence has a very low weight. Amongst all such codewords, the one with the lowest weight determines the free distance $d_{\text{free}}$ of the code. 
%$d_{\text{free}}$  of a RSC code is a very important factor and determines its error-correction performance [4].  This can be obtained from the distance spectrum of the RSC code which requires the calculation of the transfer function. The distance spectrum provides information about the number of codewords of weight $d$ generated by a message input of weight $w$. 
%The message inputs are such that they diverge from and then return to the initial state, assuming edge effect is ignored. These message inputs are referred to as Return-To-Zero (RTZ) inputs and with respect to interleaver design for turbo codes, the structure of these inputs makes it possible to design good interleavers.
%For this reason, the distance spectrum obtained as a result of the transfer function is not very useful, since it provides no information about the structure of the RTZ inputs. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states.

In this paper,we present a novel alternative method to the transfer function whose complexity is independent of the number of states of the component code, and has the added benefit of making known the structure of the RTZ inputs that make up the distance spectrum.
%With the knowledge of the structure of the message inputs, we derive a general polynomial representation for them based on the weight of the message input after which we go a step further and derive corresponding parity-weight equations for the codewords they generate. 
Using our method, we generate a partial distance spectrum for some RSC codes. Finally, we obtain the bit error rate (BER) bounds for each RSC code and compare them to the BER bounds obtained via the transfer function method and simulation results.
 %%%%%%%%%%%%%%%%%%%%%%
%Finally, we compare the upper bound for both methods to simulation results and it is revealed that the upper bound obtained by the novel method is much tighter.

The remainder of the research paper is organised as follows. In Section \ref{sec2}, we briefly introduce the notations and assumptions that will be used in the research paper. Then,we briefly review the RSC codes in Section \ref{sec3} . Moving on to Section \ref{sec5}, 
we briefly describe how the distance spectrum of an RSC Code is obtained using the transfer function, followed by the presentation of our novel method. Simulation results are presented in Section \ref{sec6} and conclude in Section \ref{sec7}.