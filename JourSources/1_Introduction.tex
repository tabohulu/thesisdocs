\section{Introduction}

The RSC code was first introduced as the component code for {\it Turbo code} (TC) \cite{Berrou93-05C}, \cite{Thitimajshima95-11C} and then applied for many other concatenated coding schemes \eg, {\it recursive convolutional space-time codes} (RC-STC) \cite{Li05-07J}, the concatenated code with {\it low-density parity-check} (LDPC) code \cite{Gounai06-06C}, {\it binary self-concatenated convolutional codes employing iterative decoding} (SECCC-ID) \cite{Butt08-11C}, and the {\it Reed-Solomon convolutional code} (RS-CC) \cite{Xu07-04C}, \cite{Byun10-09C},\cite{Joshi11-11C}. 

As the original application of RSC code, TC is known to be the first error correcting code to achieve near Shannon limit performance over AWGN channels and, nowadays, it has been adopted by many industrial standards, \eg, IEEE 802.16e \cite{802-16e-04S}, {\it digital video broadcasting} (DVB) \cite{DVB-14S}, and {\it long-term evolution} (LTE) \cite{LTE-11S}.
%RSC codes are used in concatenated codes as the binary inner code, where the codewords become the symbols to the outer non-binary code \cite{Proakis08B}. An example of such a code is the {\it Reed-Solomon Convolutional Code} (RS-CC) concatenated code, which is widely used various sysytems and widely researched \cite{Xu07-04C}, \cite{Byun10-09C},\cite{Joshi11-11C}, \cite{Joshi12-08C}. However, RSC codes were originally developed for use in parallel concatenation codes, and their most popular application is as the component code for TCs.
The TC is generally constructed by concatenating two RSC codes (usually of the same kind) parallelly  via an interleaver. A well designed TC realizes a large minimum distance via the interleaver if it maps each bit sequence with a  low-weight PC in the first RSC code onto that with a high-weight PC in the second RSC code. Thus, the design of an interleaver requires the complete knowledge of all low-weight codewords of the employed RSC code and missing even one low-weight codeword may result in TC with poor error correction performance.


The transfer function of an RSC code is an interleaver design tool that provides information about the different weights in the code, as well as their corresponding multiplicities (distance spectrum) \cite{Benedetto96-05J}. 
However, it provides no information with regards to the pattern of the low-weight codeword components. As an added downside, the complexity of calculating the transfer function for a given RSC code increases with the number of states, and other methods such as Mason's Rule \cite{Moon05B} have to be used. Research into other methods for finding the distance spectrum have been carried out in recent years.  In \cite{Lu16-10C}, an algorithm for evaluating the input-parity weight distribution of
terminated RSC codes is presented, while in \cite{Deng17-01C}, the distance spectrum of tail-biting duo-binary
RSC codes is calculated using the modified FAST algorithm. These methods also do not reveal the patterns of the codewords and to the best of our knowledge, there exists no method that provides complete knowledge of the low-weight codewords of RSC code. Because of this, many of the interleaver design methods end up ignoring some important low-weight codewords. For example, in \cite{Sun05-01J}, the interleaver design of TC does not take into account the \textbf{dominant weight-5 codewords}(mistake?)for the $5/7$  RSC code.

In this paper, we propose a method to obtain complete information about the low-weight codewords of RSC code by identifying codewords with either {\it parity-check components} (PCs) or {\it systematic components} (SCs) of weight-2 and weight-3. The complexity of our proposed method is independent of the number of states of the RSC code and its ability to also reveal the low-weight codeword patterns of RSC code makes it an excellent interleaver design tool.
To validate our proposed method, we obtain a union bound using the established low-weight codewords and comparing it to that obtained via the transfer function method and the BER curve drawn from simulation results.

The remainder of the research paper is organised as follows. Definitions used in this paper are introduced in Section \ref{secPrelim}. In Section \ref{sec2}, we discuss the characteristics of the low-weight RSC codewords and then present our method in Section \ref{sec3}. Validation of our proposed method for specific RSC codes as well as discussion of numerical results is done in Section \ref{sec4} and the paper concludes in Section \ref{sec6}.

\subsection{Notations}

For two positive integers $\alpha$ and $\beta$, the least common multiple of $\alpha$ and $\beta$ is dentoed as $\lcm(\alpha,\beta)$ while the remainder $\alpha$ divided by $\beta$ is denoted as $\alpha \mod \beta$. $\alpha | \beta$ implies $\alpha$ is a divisor of $\beta$. For an integer pair $(\alpha,~\beta)$, $(\alpha,~\beta) \bmod \epsilon_0$ is shorthand for the operation $(\alpha \bmod \epsilon_0,~\beta \bmod \epsilon_0)$. The sets of non-negative and positive integers are denoted by $\bbZ$ and $\bbZ^+$, respectively. For two integer sets $\bbM$ and $\bbN$, the tensor product that yields the set consisting of all pairs of $\bbM$ and $\bbN$ is denoted as $\bbM \otimes \bbN$ and we assume the elements in each resultant pair are sorted in increasing order. 


